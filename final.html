<!DOCTYPE html>
<html lang="en">

  <head>
    <title>Instant Dungeon</title>
    <link href="website.css" rel="stylesheet">
  </head>
  
  <body>
    
    <h1>Instant Dungeon</h1>
    <p class = "sub">Matthew Tai, April Li, Nicole Zhou, Period 4</h2>
    <hr>
    
    <h3>Project Description</h3>
    <p>Our project is a game where you have to defeat all the monsters in the level until you defeat the final boss to save the princess and win.</p>
    
    <h3>Instructions</h3>
    <p>Download the zip file and open the python file. To play the game, click the green triangle to run the current script. Use the arrow keys to move left, right, up, and down. Use the 'a' key to attack the monsters when the two collide. 3 monsters will spawn in random locations in each level, except for the last level, following the players movement while attacking them when they collide. When the players health is under 15, a health potion will spawn which will recover some of the players' health when they collide. After all monsters in the level are killed, a portal will spawn and after the player collides with the door, the player is taken to the next level. In the last level, there is only one monster, the dragon, to kill and after the dragon is killed the game is over. </p>
    
    <h3>How it works</h3>
    <p> The game is first initialized and displayed using pygame code. The display name and icon are changed using pygame, and all sprites are materialized with screen.blit. The game is kept running with a while active == True loop. When the players’ health reaches below 0, active is set to false and the display is closed. </p>
    <p> All the monster stats and pngs are stored within a csv file. The csv file is read by the code and turned  into a dictionary within a dictionary within a dictionary. The csv is first formed into lists everytime there is a new line. Then the first term of each of the lists is made the key of a dictionary, the rest of the list becoming the value of their corresponding first term of the list. Then the values of the dictionary become dictionaries where the headers become the value and the corresponding list numbers become the values. Then the entire dictionary is broken up in another dictionary, separating every 3 monsters into one level. Each key represents a level while the values are the dictionaries of 3 monsters. The next three monsters are in the next level. The dragon has its own level at 6. The main loop stops before the dragon is added, and an own loop is created for the dragon. monster_list forms a list in chronological order of levels. </p>
    <p> There are 3 enemies on each level, except for the bossfight. They are referenced in the code as monster1, monster2, and monster3. On level one, monster1 corresponds with skeleton, monster2 corresponds with zombie, and monster3 corresponds with the bat. In level two, monster1 corresponds with slime and so on. </p>
    <p> The monsters’ stats are based on the dictionary made by monster_list. monsterstats[level] will make the program look for the dictionaries of the monsters able to form in the corresponding level. Then using monster_list, it finds the index [0 + ((level - 1) * 3)] if it is monster1. This (level-1) * 3 is because the monsters form in groups of 3. The first 3 monsters monster_list are used in level one, the next 3 are used in level one. Those calculations make it so the code refers to the correct group of three. The 0 number varies from 0-2 for which monster it is. Then this is followed by what monster information you are looking for is written such as [‘Health’] or [‘Image’]. </p>
    <p> The coordinates of the monsters are randomized from a list created by giving the minimum and maximum values. The health potions’ coordinates are also randomized. These health potions only appear when the players’ health reaches below 15. </p>
    <p> Collision is detected using the distance formula, returning true or false if the entities are within 54 units of each other. If the player and monster are colliding, the players’ health is decreased by the corresponding monster’s adjusted damage stat. If the player and health potion collide, the player's health will increase based on the level. The health potion’s x and y cords are increased by 10000 so it will no longer be shown on the screen. </p>
    <p> The monster will move towards the player based on if it's x coordinates or y coordinates are less than or greater than the players’ coordinates. The monster will move a certain amount of units based on the adjusted monster speed. </p>
    <p> Using event.key, when pressing the arrow keys, the player will move in the corresponding direction 50 units. If the key ‘a’ is pressed, collision between the player and each monster is checked, and if it is true, the monsters’ health decreases based on the player's attack stat. </p>
    <p> There are boundaries placed on both the player and monsters. If the x or y values go above the maximum or below the minimum the coordinates are set to the limit, unable to make the entities move any further. </p>
    <p> The players and monsters’ health are displayed using font.render and screen.blt. The storyboard and level are also displayed using the same code. The story is displayed based on 2 lists, showing the specific strings for the corresponding levels. There are two story display functions so there can be two lines. </p>
    <p> After each monster’s health is or equal to or less than 0, the monster’s x and y cords are increased by 10000 so it won’t be displayed on the screen anymore. This will also increase the monstersdead variable by one, and when the monstersdead is equal to 3, a portal will form. </p>
    <p> When the player collides with the portal, the player is teleported to (75, 300). The players’ stats will increase, the attack stat increasing from one of the numbers 1-5. The level will increase by one. The monster setups are rewritten. There is an if level != 6: followed by monster2 and monster3 setups, while monster1 isn’t under that if function. This is because the last level, level 6, only spawns in one monster, the dragon, which is monster1. So this will spawn in monster1 but not the non existent monster2 and monster3 in the last level. The levels prior will just spawn all monsters. </p>
    <p> If the level is greater or equal to 6, the princess will appear. When the dragon’s health, monsterhealth1, is below or equal to 0, it is teleported and the code also checks if the is level 6 to set the level to 7 in order to change the story into the congratulations message. When the play collides with the portal, the game is closed out. </p>
  
    <h3>Files</h3>
    <ul>
      <li>final.html: This html file</li>
      <li>website.css: The css file used to style final.html</li>
      <li>final_project.py: The python function that contains the code of the game and where you can play the game</li>
      <li>monsterstats.csv: The csv file containing the stats and pngs of all the monsters in the game</li>
      <li>Images:</li>
      <ul>
        <li>portal.png: The png of the portal</li>
        <li>health_potion.png: The png of the health potion</li>
        <li>skeleton.png: The png of the skeleton</li>
        <li>zombie.png: The png of the zombie</li>
        <li>bat.png: The png of the bat</li>
        <li>slime.png: The png of the slime</li>
        <li>goblin.png: The png of the goblin</li>
        <li>kobold.png: The png of the kobold</li>
        <li>troll.png: The png of the troll</li>
        <li>orc.png: The png of the orc</li>
        <li>ogre.png: The png of the ogre</li>
        <li>two_headed_ogre.png: The png of the two headed ogre</li>
        <li>goblin_priest.png: The png of the goblin priest</li>
        <li>orc_chieftan.png: The png of the orc chieftan</li>
        <li>lich.png: The png of the lich</li>
        <li>grim_reaper.png: The png of the grim reaper</li>
        <li>burning_slime.png: The png of the burning slime</li>
        <li>dragon.png: The png of the dragon</li>
        <li>princess.png: The png of the princess</li>
      </ul>
    </ul>
    
    <h3>Resources</h3>
    <ul>
      <li>Pygame commands: <a href="https://www.pygame.org/docs/">https://www.pygame.org/docs/</a></li>
      <li>Icons: <a href="https://www.flaticon.com/">https://www.flaticon.com/</a></li>
      <li>HTML: <a href="https://www.w3schools.com/html/default.asp">https://www.w3schools.com/html/default.asp</a></li>
      
    </ul>
    <p>For this project, we used pygame, a python library not covered in class. We will be using pygame to create our game. PyGame is a necessity for this project to work. It provides us with all of the basic essentials for creating a game; things that aren’t possible for us to do with what we learned in class or in regular python. If they are possible in regular python, it would include a lot of extra code that would be easier to just use pygame. For example an easy to modify display for the game, including players and monsters, as well as controls that are triggered by one’s keyboard. The keybinds are essential for playing the game, and its easy-to-use display feature makes it possible for us to provide graphics in our game.</p>
    
    <h3>Bugs, Errors, and Things to be Aware of</h3>
    <ul>
      <li>Spamming the attack key is reccomended otherwise failure is guaranteed</li>
      <li>Can have 0.0 health left even though the code is written such if the playerhealth is <= 0, then the player should die.</li>
      <li>In order to view the death message, you have to stay still otherwise the game will just close out</li>
    </ul>
    
  </body>
  
</html>
